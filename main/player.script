local moku = require("moku.moku")
local camera = require("orthographic.camera")
local selected = {}
local moving = false
local delay = 0.2

local moku_ids = {
    WALL = 1,
    FLOOR = 2
}

local tile_costs = {
    [moku_ids.WALL] = -1,
    [moku_ids.FLOOR] = 1,
    [0] = -1
}

local function move_to_tile(map, tile, url, animate)
    local setX, setY = moku.cell_center(map, map.pos.x, map.pos.y, tile.moku_x, tile.moku_y)
    if animate == false then
    go.set(url, "position", vmath.vector3(setX, setY, 1))
  else
    local newPos = vmath.vector3(setX, setY, go.get_position(url).z)
    go.animate(url, "position", go.PLAYBACK_ONCE_FORWARD, newPos, go.EASING_LINEAR, delay)
  end
end

local function cost_fn(args)
    return args.user[args.to_cell.moku_id]
end

function init(self)
    msg.post(".", "acquire_input_focus")
    msg.post("camera", "acquire_camera_focus")
    msg.post("@render:", "use_fixed_fit_projection", {near = 0, far = 15})
    self.map = moku.new_from_tm("/world#main", "layer1", 16, 16)
    self.map.pos = go.get_position("/world")
    self.map.pathfinder.allowed_directions = moku.dir_tables.CARDINAL
end

function on_input(self, action_id, action)
    if action.x and action.y then
        local mousePos = camera.screen_to_world(nil, vmath.vector3(action.x, action.y, 1))

        local tile = moku.pick_cell(self.map, self.map.pos.x, self.map.pos.y, mousePos.x, mousePos.y)

        if tile ~= nil then
          move_to_tile(self.map, tile, "/selector", false)
        end
    end

    if action_id == hash("touch") then
        if action.released then
            if moving == true then
                return
            end

            local mousePos = camera.screen_to_world(nil, vmath.vector3(action.x, action.y, 1))
            local tile = moku.pick_cell(self.map, self.map.pos.x, self.map.pos.y, mousePos.x, mousePos.y)
            local player =
                moku.pick_cell(self.map, self.map.pos.x, self.map.pos.y, go.get_position().x, go.get_position().y)

            if tile == nil then
                return
            end
            if tile.moku_id ~= 2 then
                return
            end
            moving = true
            selected = tile
            local iterator = 1

            local path = moku.find_path(self.map, player, tile, cost_fn, tile_costs)

            if path == nil then
                msg.post("/selector#sprite", "play_animation", {id = hash("refuse")})
                moving = false
                selected = {}
                return
            end

            local path_size = table.maxn(path)

            msg.post("/player#sprite", "play_animation", {id = hash("moving")})
            msg.post("/selector#sprite", "play_animation", {id = hash("confirm")})

            self.moveTimer =
                timer.delay(
                delay,
                true,
                function(self)
                    if iterator > path_size - 1 then
                        moving = false
                        timer.cancel(self.moveTimer)
                        self.moveTimer = nil
                        msg.post("#sprite", "play_animation", {id = hash("player")})
                        return
                    end
                    iterator = iterator + 1
                    move_to_tile(self.map, path[iterator], "/player", true)
                end
            )
        else
            msg.post("/selector#sprite", "play_animation", {id = hash("refuse")})
        end
    end
end

function on_message(self, message_id, message, sender)
    if message_id == hash("animation_done") then
        msg.post("/selector#sprite", "play_animation", {id = hash("normal")})
    end
end

